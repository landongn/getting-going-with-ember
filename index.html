<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Getting Going With Ember.js</title>

		<meta name="description" content="Getting going with Ember -- Not to be confused with getting started with ember.">
		<meta name="author" content="Landon Noss">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/night.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<style>
			.emberized, h1 {
				background: linear-gradient(to bottom, #fe845a, #d14e37); -webkit-background-clip: text;-webkit-text-fill-color: transparent;
			}</style>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>
		<img src="https://pbs.twimg.com/profile_images/575139003965399040/avFNd_1r.png" style="position:fixed; bottom: 0; left: 0; border-radius: 10px; height: 48px; width: 48px;">
		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

				<section>
					<h1 style="font-size: 2.5em;">Getting Going With <span class="emberized">Ember</span></h1>
					<p>
						<small>Created by <a href="http://landongn.com">Landon Noss</a> / <a href="http://twitter.com/landongn">@landongn</a></small>
					</p>
				</section>

				<section>
					<section>
						<h1 class="emberized">Who Am I?</h2>
						<h2>I'm Landon</h2>
						<p class="fragment">I'm a full stack developer, but my primary focus is on front-end.</p>
						<p class="fragment">I work for Gaikai / Sony Network Entertainment International <br />
						(I help build PlayStation Now)</p>
						<p class="fragment">I've been writing ember for about three years.</p>
					</section>

					<section>
						<h2>I've been a javascripter for...ever.</h2>
						<p class="fragment">I started out writing bad javascript</p>
						<p class="fragment">then bad jQuery</p>
						<p class="fragment">then bad Backbone</p>
						<p class="fragment">then bad Angular</p>
						<p class="fragment">then bad Ember</p>
						<p class="fragment">then kinda good Ember</p>
						<aside class="notes">
							<p>Started out writing giant object literals in namespaces</p>
							<p>then decided to write everything as a plugin</p>
							<p>then classes were a thing</p>
							<p>then routing and controllers were popular</p>
							<p>then i wrote piles and piles of imperative, procedural ember</p>
							<p>then i started trying to write more declarative ember</p>
							<p>imperative versus declarative was mostly a sanity choice.</p>
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h2>The Subjective Stuff:</h2>
						<p class="fragment">It's flexible.</p>
						<p class="fragment">It's terse.</p>
						<p class="fragment">It's compatable.</p>
						<p class="fragment">It's written in vanilla ES6.</p>
						<p class="fragment">It's RFC Process.</p>
						<p class="fragment">It's Community</p>

						<aside class="notes">
							<p>I want to have sensible defaults that do 75% of what I want, and well furnished toolbox to accomplish the last 25%</p>
							<p>That last 25% is usually animations, event handling, and templates </p>
							<p>I want to be able to use almost<sup>*</sup> any library in a straightforward way</p>
							<p>I have to know how it's written under the hood, without having to learn someone elses opinion on how javascript should work</p>
							<p>I want to know where the framework is headed, both short and long term, so I can better manage change on my codebase</p>
							<p>Updating to a new version warns me if the next version bump will depreciate something, via my console</p>
						</aside>
					</section>

					<section>
						<h2>The Super Subjective Stuff:</h2>
						<p class="fragment">Working with teams is <span class="emberized">hard</span></p>
						<p class="fragment">Ember helps define a grammar</p>
						<p class="fragment">Class types all have the same API</p>
						<p class="fragment">Moving the important state management into the URL is really important</p>
						<aside class="notes">
							<p>every developer has their own preferences for implementing common stuff </p>
							<p>that argument wastes time that could be spent just building a thing</p>
							<p>ember is completely batteries included, and has a deep catalog of features</p>
							<p>because a route is a route is a route, making changes is simplified, as is debugging</p>
							<p>the router, when used appropriately, simplifies state management immensely</p>
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h2>So what even <i>is</i> an Ember?</h2>
					</section>
					<section>
						<h2>The most important parts</h2>
						<h3 class="fragment">uhh</h3>
						<h3 class="fragment">well...</h3>
					</section>
					<section>
						<h2>Lets talk about a few concepts first</h2>
					</section>
				</section>

				<section>
					<section>
						<h2>Single Responsibility Principle</h2>
						<p>Every class should have responsibility over a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class</p>
						<p>- wikipedia.com | Robert C. Martin</p>
					</section>

					<section>
						<h2>Uniform Access Principle</h2>
						<p>All services offered by a module should be available through a uniform notation, 
						which does not betray whether they are implemented through storage or through computation</p>
						<p>- wikipedia.com | Bertrand Meyer</p>
					</section>

					<section>
						<h2>So what?</h2>
					</section>

					<section>
					<h2>show of hands: who's written this function before?</h2>
<pre data-trim>
<code>

parseData: function (data) {
  this.name = data.name;
  this.email = data.email;
  this.token = data.token;
  this.fullName = data.firstName + ' ' + data.lastName;
  this.validAccount = data.has_verified ? true : false;
}

</code>
</pre>
					</section>

					<section>
						<h2>what about this?</h2>
<pre data-trim>
<code>

filterSet: function (key) {
  var ret = [];
  for (var i = 0; i > this.set; i++) {
    if (this.set[i].prop === key) {
      ret.push(this.set[i]);
    }
  }
  return ret;
}

</code>
</pre>
					</section>

					<section>
						<h2>This sucks. </h2>
						<p class="fragment">We're so busy writing the <i class="emberized">how</i></p>
						<p class="fragment">we sometimes lose sight of the <i class="emberized">what</i></p>
					</section>
				</section>

				<section>

					<section>
						<h2>How can <span class="emberized">Ember</span> help us write better code?</h2>
					</section>

					<section>
						<h2>The Router</h2>
						<p class="fragment">Build lots of explicit states</p>
						<p class="fragment">then build small things that react to that change</p>
					</section>

					<section>
						<h2>The Router is kind of like a rubix cube with callbacks.</h2>
						<p class="fragment">When the router detects a change, it kicks off a series of ordered events -- a lifecyle -- that reconfigures <i>all the things.</i></p>
					</section>

					<section>
						<h2>Defining the Router</h2>
<pre data-trim><code>
// app/router.js
Router.map(function() {

  // defines a standalone route with no substates or arguments
  // routable as 'stateA'
  this.route('stateA');

  // defines a standalone route with no substates and an argument
  // routable as 'stateB'
  this.route('stateB', {path: '/stateB/:someArgument'});

  // defines a route with a child state
  // routable as superState.loading, superState.error,
  // superState.index, superState.childState
  this.route('superState', function () {
  	this.route('childState');
  });

});

</code></pre>
					</section>

					<section>
						<h2>Ember conventions expect that names have meaning to the application</h2>
						<p class="fragment">since we defined <code>superState</code> in our router</p>
						<p class="fragment">a <code>SuperStateRoute</code> should exist</p>
						<p class="fragment">as well as a <code>SuperStateController</code></p>
					</section>

					<section>
						<h2>Ember tries to create stubs where it needs</h2>
						<p class="fragment">If you dont define a <code>SuperStateController</code></p>
						<p class="fragment">Ember creates an empty <code>Controller</code> instance for you, at runtime</p>
					</section>

					<section>
						<h2>Now that we have routes defined, how do we implement them?</h2>
						<p class="fragment">Ember runs on the backbone of a runloop</p>
						<p class="fragment">the runloop executes a lifecycle of events in a specific order</p>
					</section>

					<section>
						<h2>the order goes a bit like this, for a route class</h2>
					</section>

					<section>
						<p class="fragment"><code>beforeModel(transition)</code></p>
						<p class="fragment">
							<code>
								model(params)
							</code>
						</p>
						<p class="fragment">
							<code>
								afterModel()
							</code>
						</p>
						<p class="fragment">
							<code>
								setupController(controller, model)
							</code>
						</p>
						<p class="fragment">
							<code>
								renderTemplate()
							</code>
						</p>
					</section>
					<section>
						<h2>Routes have a <span>lifecycle</span> whenever state changes</h2>
						<p class="fragment">it's your job as an ember developer to fulfill events in that lifecycle</p>
					</section>

					<section>
						<h2>the <code>model</code> hook is all about data</h2>
						<p class="fragment">whatever you return from this method is provided to the child controller and templates</p>
						<p class="fragment">controllers, components, and templates use this data to display your UI</p>
					</section>

					<section>
<pre data-trim>
<code>
// app/route.js
  model: function (params) {
    Ember.$.getJSON('/api/user').then(function (response) {
      return response;
    });
  }
</code></pre>
					</section>

					<section>
<pre data-trim>
<code>
// app/template.hbs
<h2>Hi, {{name}}!</h2>
</code></pre>
					</section>

					



					<section>
						<h2>Routes &amp; Templates</h2>
						<p class="fragment">
							Templates are the structure your app, via outlets and components.
						</p>
						<p class="fragment">
							User events go down the stack, actions go up the stack.
						</p>
						<p class="fragment">other than components, routes are the only classes that actually render to the dom</p>
					</section>

					<section>
						<img src="view_layer.png" alt="">
					</section>

					<section>
						<h2>Components define sensible chunks of your abstraction</h2>
						<p class="fragment">they operate kind of like a template and a view, squished together</p>
						<p class="fragment">there's no reason you shouldn't have a component render another component</p>
						<p class="fragment">or even an entire suite of components</p>
					</section>

					<section>
						<h2>Components are just dom</h2>
						<p class="fragment">every component defines a single dom element</p>
						<p class="fragment">it can be as simple or complex as you want it to be</p>
						<p class="fragment"><code>tagName, classNames, attributeBindings</code> are all part of the component spec</p>
						<p class="fragment">defining a component for an image? define it's <code>src</code> property, and it's <code>tagName</code> and you're done</p>
					</section>

					<section>
						<h2>But they don't have to be complex dom</h2>
						<p class="fragment">writing component-of-components is encouraged</p>
						<p class="fragment">Controllers are going away <span class="emberized">in Ember 2.0</span></p>
						<p class="fragment">Components will take their place once they go away</p>
					</section>

					<section>
						<h2>Handling events is easy with components</h2>
						<ul class="fragment" style="float:left; width: 30%; border: none; box-shadow: none;">
							<li><pre style="box-shadow:none; font-size: 1em;">click()</pre></li>
							<li><pre style="box-shadow:none; font-size: 1em;">dlbclick()</pre></li>
							<li><pre style="box-shadow:none; font-size: 1em;">focusin()</pre></li>
							<li><pre style="box-shadow:none; font-size: 1em;">focusout()</pre></li>
						</ul>
						<ul class="fragment" style="float:left; width: 30%; border: none; box-shadow: none;">
							<li><pre style="box-shadow:none; font-size: 1em;">touchstart()</pre></li>
							<li><pre style="box-shadow:none; font-size: 1em;">touchmove()</pre></li>
							<li><pre style="box-shadow:none; font-size: 1em;">touchend()</pre></li>
							<li><pre style="box-shadow:none; font-size: 1em;">dragstart()</pre></li>
						</ul>
						<ul class="fragment" style="float:left; width: 30%; border: none; box-shadow: none;">
							<li><pre style="box-shadow:none; font-size: 1em;">keypress()</pre></li>
							<li><pre style="box-shadow:none; font-size: 1em;">submit()</pre></li>
							<li><pre style="box-shadow:none; font-size: 1em;">change()</pre></li>
							<li><pre style="box-shadow:none; font-size: 1em;">input()</pre></li>
						</ul>
					</section>

					<section>
						<h2>The rule of thumb when handling user interaction:</h2>
						<p class="fragment">raw dom events are handled as normal JS events</p>
						<p class="fragment">if those events end up doing something important to the app</p>
						<p class="fragment">then actions are used to propagate that mutation elsewhere</p>
					</section>

				</section>

				<section>
					<section>
						<h2>Actions help you define the <span class="emberized">what</span>.</h2>
						<p class="fragment">Actions can be defined on Components, Routes, Controllers and Views</p>
						<p class="fragment">They exist in an <code>actions: {}</code> object in those classes</p>
						<p class="fragment">they're invoked by calling <code>this.send('actionName');</code></p>
					</section>

					<section>
						<h2>Actions that get invoked but are not defined do magic</h2>
						<p class="fragment">rather than throwing an exception, they'll check the immediate parent</p>
						<p class="fragment">if a component calls <code>send</code>, it's templates controller is checked</p>
						<p class="fragment">if that action isn't defined on the controller, it'll check the active route</p>
						<p class="fragment">if it's not defined on the route, it'll check it's parent route, if any</p>
						<p class="fragment">finally, it'll check the application route instance</p>
					</section>

					<section>
						<h2>Actions should be used at an abstraction above raw events.</h2>
						<p class="fragment">Actions do one thing.</p>
						<p class="fragment">Actions don't care where the event came from</p>
						<p class="fragment">Actions (on routes) are the only place you can render templates</p>
						<p class="fragment">Actions (on routes) are the only place you can redirect, other than {{link-to}}</p>
					</section>
				</section>
					
				<section>
					<section>
						<h2>My Best Friends are Computed</h2>
						<p class="fragment">Computed Properties simplify the act of working with data</p>
						<p class="fragment">Rather than explicitly setting properties for everything in one big method</p>
						<p class="fragment">Define the properties based on the existance of some immutable data</p>
					</section>

					<section>
<pre data-trim>
	<code>
//stateA/controller.js [note: does NOT use prototype extensions]
// side note: this is the preferred way to do it.
export default Ember.Controller.extend({

  // define a computed property that updates
  // a slice of an array when it's filtering key changes.
  arraySlice: Ember.computed('filterProp', function (key, value) {

    var thisSlice = [];
    var filter = this.get("filterProp");
    this.get('arrayData').forEach(function (item, iter) {
      if (item.get(filter)) {
        thisSlice.push(item);
      }
    });
    return thisSlice;
  }
});
	</code>
</pre>
					</section>

					<section>
<pre data-trim>
	<code>
//stateA/controller.js [note: does NOT use prototype extensions]
// side note: this is the preferred way to do it.
export default Ember.Object.extend({

  userModel: {},
  fullName: Ember.computed('userModel', function () {
	return this.get('userModel.firstName') + ' ' + this.get('userModel.lastName');
  }),

  hasVerified: Ember.computed('userModel.token', function () {
    return this.get('userModel.token').length >= 32;
  })
});
	</code>
</pre>
					</section>

					<section>
						<h2>Computed properties are cached</h2>
						<p class="fragment">every time a computed is referenced, it's cached value is returned</p>
						<p class="fragment">the only thing that will force an update to the interal property is a change to the observed property</p>
						<p class="fragment">invert the way you define classes through computed properties</p>
						<p class="fragment">treat the internal data that powers them as immutable</p>
					</section>

					<section>
					<p>There's some great APIs to be found in the <code>computed</code> namespace</p>
						<ul style="float:left; width: 30%; border: none; box-shadow: none;">
							<li><pre style="box-shadow:none; font-size: 1em;">mapBy</pre></li>
							<li><pre style="box-shadow:none; font-size: 1em;">filterBy</pre></li>
							<li><pre style="box-shadow:none; font-size: 1em;">equal</pre></li>
							<li><pre style="box-shadow:none; font-size: 1em;">match</pre></li>
						</ul>
						<ul style="float:left; width: 30%; border: none; box-shadow: none;">
							<li><pre style="box-shadow:none; font-size: 1em;">min</pre></li>
							<li><pre style="box-shadow:none; font-size: 1em;">sum</pre></li>
							<li><pre style="box-shadow:none; font-size: 1em;">union</pre></li>
							<li><pre style="box-shadow:none; font-size: 1em;">and</pre></li>
						</ul>
						<ul style="float:left; width: 30%; border: none; box-shadow: none;">
							<li><pre style="box-shadow:none; font-size: 1em;">empty</pre></li>
							<li><pre style="box-shadow:none; font-size: 1em;">sort</pre></li>
							<li><pre style="box-shadow:none; font-size: 1em;">uniq</pre></li>
							<li><pre style="box-shadow:none; font-size: 1em;">intersect</pre></li>
						</ul>
					</section>
				</section>

			<section>
				<h2>Code Demo</h2>
			</section>

			<section>
				<section>
					<h2>What Advice would I give to someone starting to learn ember?</h2>
				</section>

				<section>
					<h2>Don't fight the framework</h2>
					<p class="fragment">It's important to learn the conventions.</p>
					<p class="fragment">Whenever you catch yourself having an argument with ember, you've lost.</p>
					<p class="fragment">Be incredibly liberal with the amount of components you create.</p>
					<p class="fragment">Same goes for routes. You're supposed to build a lot of them.</p>
				</section>

				<section>
					<h2>Observers and Computed Properties make your APIs nice</h2>
					<p class="fragment">Think hard about who you're writing this code for. It's not the user.</p>
					<p class="fragment">Make sure the way you design your class adheres to the Universal Access Principle</p>
					<p class="fragment">Rather than parsing data and setting properties, define computed properties that do their own work</p>
					<p class="fragment">The goal is to write maintainable, easy to grok code.</p>
				</section>
				
				<section>
					<h2>Outlets and how they work are pretty critical.</h2>
					<p class="fragment">Outlets define a section of the dom that templates render into</p>
					<p class="fragment">sub-views are trivial, if you have an outlet, since you can nest them recursively</p>
					<p class="fragment">in practice, this means that a route without substates doesn't use an outlet</p>
					<p class="fragment">but a route with substates <i>requires</i> an outlet for children to render to</p>
				</section>
			</section>

			<section>
				<section>
					<h2>Ember isn't all about MVC</h2>
					<p class="fragment">It's more like a really nuanced state management library</p>
					<p class="fragment">that also has a stellar functional programming library</p>
					<p class="fragment">and super powerful, flexible, and expressive components</p>
				</section>
			</section>


			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
